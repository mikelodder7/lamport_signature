/*
    Copyright Michael Lodder. All Rights Reserved.
    SPDX-License-Identifier: Apache-2.0
*/
use crate::{LamportDigest, LamportError, LamportResult, MultiVec};
use std::marker::PhantomData;

/// A signature data generated by [SigningKey].
#[derive(Debug, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct Signature<T: LamportDigest> {
    pub(crate) data: MultiVec<u8, 2>,
    pub(crate) algorithm: PhantomData<T>,
}

serde_impl!(Signature);

impl<T: LamportDigest> Signature<T> {
    /// Constructs a [`Signature`] from a byte sequence
    pub fn from_bytes<B: AsRef<[u8]>>(bytes: B) -> LamportResult<Self> {
        let bytes = bytes.as_ref();
        let digest_size_in_bits = T::digest_size_in_bits();
        let digest_size_in_bytes = digest_size_in_bits / 8;
        let required_size_in_bytes = digest_size_in_bytes * digest_size_in_bits;
        if bytes.len() != required_size_in_bytes {
            return Err(LamportError::InvalidSignatureBytes);
        }
        let data = MultiVec {
            data: bytes.to_vec(),
            axes: [digest_size_in_bits, digest_size_in_bytes],
        };
        Ok(Self {
            data,
            algorithm: PhantomData,
        })
    }

    /// Converts the inner signature data into a linearized vector.
    pub fn to_bytes(&self) -> Vec<u8> {
        self.data.data.clone()
    }
}
