/*
    Copyright Michael Lodder. All Rights Reserved.
    SPDX-License-Identifier: Apache-2.0
*/
use crate::{LamportDigest, LamportError, LamportResult, MultiVec};
use serde::{Deserialize, Serialize};
use std::marker::PhantomData;

/// A signature data generated by [SigningKey].
#[derive(Debug, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct Signature<T: LamportDigest> {
    pub(crate) data: MultiVec<u8, 2>,
    pub(crate) algorithm: PhantomData<T>,
}

impl<T: LamportDigest> Serialize for Signature<T> {
    fn serialize<S>(&self, s: S) -> Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        let bytes = self.to_bytes();
        if s.is_human_readable() {
            hex::encode(&bytes).serialize(s)
        } else {
            s.serialize_bytes(&bytes)
        }
    }
}

impl<'de, T: LamportDigest> Deserialize<'de> for Signature<T> {
    fn deserialize<D>(d: D) -> Result<Self, D::Error>
    where
        D: serde::de::Deserializer<'de>,
    {
        let bytes = if d.is_human_readable() {
            let hex_str = String::deserialize(d)?;
            hex::decode(hex_str).map_err(serde::de::Error::custom)?
        } else {
            Vec::<u8>::deserialize(d)?
        };
        Signature::from_bytes(bytes).map_err(serde::de::Error::custom)
    }
}

impl<T: LamportDigest> Signature<T> {
    /// Constructs a [`Signature`] from a byte sequence
    pub fn from_bytes<B: AsRef<[u8]>>(bytes: B) -> LamportResult<Self> {
        let bytes = bytes.as_ref();
        let digest_size_in_bits = T::digest_size_in_bits();
        let digest_size_in_bytes = digest_size_in_bits / 8;
        let required_size_in_bytes = digest_size_in_bytes * digest_size_in_bits;
        if bytes.len() != required_size_in_bytes {
            return Err(LamportError::InvalidSignatureBytes);
        }
        let data = MultiVec {
            data: bytes.to_vec(),
            axes: [digest_size_in_bits, digest_size_in_bytes],
        };
        Ok(Self {
            data,
            algorithm: PhantomData,
        })
    }

    /// Converts the inner signature data into a linearized vector.
    pub fn to_bytes(&self) -> Vec<u8> {
        self.data.data.clone()
    }
}
