/*
    Copyright Michael Lodder. All Rights Reserved.
    SPDX-License-Identifier: Apache-2.0
*/
use crate::{LamportDigest, LamportError, LamportResult, MultiVec};
use std::marker::PhantomData;
use vsss_rs::{combine_shares, Gf256};

/// A signature data generated by [`SigningKey`].
#[derive(Debug, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct Signature<T: LamportDigest> {
    pub(crate) data: MultiVec<u8, 2>,
    pub(crate) algorithm: PhantomData<T>,
}

serde_impl!(Signature);
vec_impl!(Signature);

impl<T: LamportDigest> Signature<T> {
    /// Constructs a [`Signature`] from a byte sequence
    pub fn from_bytes<B: AsRef<[u8]>>(bytes: B) -> LamportResult<Self> {
        let bytes = bytes.as_ref();
        let digest_size_in_bits = T::digest_size_in_bits();
        let digest_size_in_bytes = digest_size_in_bits / 8;
        let required_size_in_bytes = digest_size_in_bytes * digest_size_in_bits;
        if bytes.len() != required_size_in_bytes {
            return Err(LamportError::InvalidSignatureBytes);
        }
        let data = MultiVec {
            data: bytes.to_vec(),
            axes: [digest_size_in_bits, digest_size_in_bytes],
        };
        Ok(Self {
            data,
            algorithm: PhantomData,
        })
    }

    /// Converts the inner signature data into a linearized vector.
    pub fn to_bytes(&self) -> Vec<u8> {
        self.data.data.clone()
    }

    /// Combines multiple signature shares into a single signature.
    pub fn combine(shares: &[SignatureShare<T>]) -> LamportResult<Self> {
        if shares.is_empty() {
            return Err(LamportError::InvalidSignatureBytes);
        }
        if shares.len() < shares[0].threshold as usize {
            return Err(LamportError::VsssError(vsss_rs::Error::SharingMinThreshold));
        }

        let mut out = Self {
            data: MultiVec::fill(shares[0].data.axes, 0u8),
            algorithm: PhantomData,
        };
        let mut share_bytes = vec![[0u8; 2]; shares.len()];
        for i in 0..shares[0].data.len() {
            for (j, share) in shares.iter().enumerate() {
                share_bytes[j][0] = share.identifier;
                share_bytes[j][1] = share.data.data[i];
            }
            out.data.data[i] = combine_shares::<Gf256, u8, [u8; 2]>(&share_bytes)?.0;
        }
        Ok(out)
    }
}

/// A signature share generated by [`SigningKeyShare`].
#[derive(Debug, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct SignatureShare<T: LamportDigest> {
    pub(crate) identifier: u8,
    pub(crate) threshold: u8,
    pub(crate) data: MultiVec<u8, 2>,
    pub(crate) algorithm: PhantomData<T>,
}

serde_impl!(SignatureShare);
vec_impl!(SignatureShare);

impl<T: LamportDigest> SignatureShare<T> {
    /// Constructs a [`SignatureShare`] from a byte sequence
    pub fn from_bytes<B: AsRef<[u8]>>(bytes: B) -> LamportResult<Self> {
        let bytes = bytes.as_ref();
        let digest_size_in_bits = T::digest_size_in_bits();
        let digest_size_in_bytes = digest_size_in_bits / 8;
        let required_size_in_bytes = digest_size_in_bytes * digest_size_in_bits;
        if bytes.len() != required_size_in_bytes + 2 {
            return Err(LamportError::InvalidSignatureBytes);
        }
        if bytes[0] == 0 {
            return Err(LamportError::InvalidSignatureBytes);
        }
        if bytes[1] < 2 {
            return Err(LamportError::InvalidSignatureBytes);
        }
        let data = MultiVec {
            data: bytes[2..].to_vec(),
            axes: [digest_size_in_bits, digest_size_in_bytes],
        };
        Ok(Self {
            identifier: bytes[0],
            threshold: bytes[1],
            data,
            algorithm: PhantomData,
        })
    }

    /// Converts the inner signature data into a linearized vector.
    pub fn to_bytes(&self) -> Vec<u8> {
        let mut bytes = vec![0u8; self.data.data.len() + 2];
        bytes[0] = self.identifier;
        bytes[1] = self.threshold;
        bytes[2..].copy_from_slice(&self.data.data);
        bytes
    }
}
